// src/models/AuditLog.js
const mongoose = require('mongoose');

/**
 * AUDIT LOG MODEL
 * 
 * Records every significant action in the system
 * 
 * Why Audit Logs Matter in Production:
 * 1. Security - Track unauthorized access attempts
 * 2. Compliance - GDPR, FERPA, data protection laws
 * 3. Debugging - Trace issues ("Who changed this grade?")
 * 4. Accountability - Prove who did what
 * 5. Forensics - Investigate incidents
 * 
 * Real-world scenarios:
 * - Parent disputes: "I never received that invoice"
 *   → Check audit log for invoice generation
 * - Grade changes: "Who changed my child's grade?"
 *   → Audit log shows teacher X on date Y
 * - Data breach: "What data was accessed?"
 *   → Audit log shows all read operations
 * 
 * This is NOT optional in professional systems.
 */

const auditLogSchema = new mongoose.Schema({
  // Who performed the action
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },

  // What action was performed
  action: {
    type: String,
    required: true,
    enum: [
      // Authentication
      'login', 'logout', 'login_failed',
      
      // Student operations
      'student_created', 'student_updated', 'student_deleted', 'student_viewed',
      
      // Enrollment operations
      'enrollment_created', 'enrollment_updated', 'enrollment_transferred',
      
      // Attendance operations
      'attendance_marked', 'attendance_updated',
      
      // Financial operations
      'invoice_created', 'invoice_updated', 'invoice_cancelled',
      'payment_recorded', 'payment_refunded',
      
      // Grade operations
      'grade_created', 'grade_updated', 'grade_deleted',
      
      // User operations
      'user_created', 'user_updated', 'user_deactivated',
      
      // Class operations
      'class_created', 'class_updated', 'class_deleted',
      
      // Security events
      'unauthorized_access', 'permission_denied',
      
      // Data exports
      'data_exported', 'report_generated'
    ],
    index: true
  },

  // What entity was affected
  entity: {
    type: String,
    required: true,
    enum: ['user', 'student', 'teacher', 'parent', 'class', 'enrollment', 
           'attendance', 'invoice', 'payment', 'grade', 'report'],
    index: true
  },

  // ID of the affected entity
  entityId: {
    type: mongoose.Schema.Types.ObjectId,
    index: true
  },

  // School context (multi-tenancy)
  schoolId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'School',
    required: true,
    index: true
  },

  // What changed (for update operations)
  changes: {
    before: mongoose.Schema.Types.Mixed, // State before
    after: mongoose.Schema.Types.Mixed   // State after
  },

  // Request metadata
  ipAddress: {
    type: String,
    required: true
  },

  userAgent: {
    type: String
  },

  // Success or failure
  success: {
    type: Boolean,
    default: true,
    index: true
  },

  // Error details if failed
  errorMessage: {
    type: String
  },

  // Additional context
  metadata: {
    type: mongoose.Schema.Types.Mixed
    // Store any additional relevant data
  },

  // Timestamp (auto-generated by timestamps: true)
  // But we explicitly index it
  
}, {
  timestamps: { 
    createdAt: true, 
    updatedAt: false // Audit logs are never updated
  }
});

/**
 * INDEXES - TIME-SERIES OPTIMIZED
 * 
 * Audit logs grow FAST. Indexes are critical.
 */

// Query by user over time
auditLogSchema.index({ userId: 1, createdAt: -1 });

// Query by entity
auditLogSchema.index({ entity: 1, entityId: 1, createdAt: -1 });

// Query by school (multi-tenancy)
auditLogSchema.index({ schoolId: 1, createdAt: -1 });

// Query by action type
auditLogSchema.index({ action: 1, createdAt: -1 });

// Security queries (failed actions)
auditLogSchema.index({ success: 1, action: 1, createdAt: -1 });

// Compound for common queries
auditLogSchema.index({ schoolId: 1, entity: 1, createdAt: -1 });

/**
 * STATIC METHODS
 */

// Log any action (main method)
auditLogSchema.statics.log = async function(logData) {
  try {
    return await this.create(logData);
  } catch (error) {
    // CRITICAL: Never let audit logging break the main operation
    console.error('Audit log failed:', error);
    // In production, send to error monitoring service
    return null;
  }
};

// Get audit trail for an entity
auditLogSchema.statics.getEntityHistory = function(entity, entityId, limit = 50) {
  return this.find({ entity, entityId })
    .populate('userId', 'email role')
    .sort('-createdAt')
    .limit(limit);
};

// Get user's activity log
auditLogSchema.statics.getUserActivity = function(userId, startDate, endDate) {
  const query = { userId };
  if (startDate && endDate) {
    query.createdAt = {
      $gte: new Date(startDate),
      $lte: new Date(endDate)
    };
  }
  return this.find(query).sort('-createdAt');
};

// Security monitoring: Failed login attempts
auditLogSchema.statics.getFailedLogins = function(hours = 24) {
  const since = new Date(Date.now() - hours * 60 * 60 * 1000);
  return this.aggregate([
    {
      $match: {
        action: 'login_failed',
        createdAt: { $gte: since }
      }
    },
    {
      $group: {
        _id: '$ipAddress',
        count: { $sum: 1 },
        lastAttempt: { $max: '$createdAt' }
      }
    },
    {
      $match: { count: { $gte: 5 } } // 5+ failed attempts
    },
    {
      $sort: { count: -1 }
    }
  ]);
};

// Compliance report: Data access log
auditLogSchema.statics.getDataAccessLog = function(entityType, entityId, days = 90) {
  const since = new Date(Date.now() - days * 24 * 60 * 60 * 1000);
  return this.find({
    entity: entityType,
    entityId: entityId,
    action: { $regex: /_viewed$/ },
    createdAt: { $gte: since }
  })
    .populate('userId', 'email role')
    .sort('-createdAt');
};

/**
 * MIDDLEWARE
 */

// Prevent updates to audit logs (immutable)
auditLogSchema.pre('save', function(next) {
  if (!this.isNew) {
    return next(new Error('Audit logs cannot be modified'));
  }
  next();
});

// Prevent deletion of audit logs
auditLogSchema.pre('remove', function(next) {
  return next(new Error('Audit logs cannot be deleted'));
});

/**
 * EXPLAIN TO STUDENT - DEEP DIVE
 * 
 * Q: Why is audit logging so important?
 * A: LEGAL AND OPERATIONAL NECESSITY
 * 
 *    Example 1: GDPR Compliance (EU Law)
 *    - Requirement: Log all access to personal data
 *    - If user requests: "Who accessed my child's data?"
 *    - You MUST be able to provide complete log
 *    - Fines for non-compliance: Up to 4% of global revenue
 * 
 *    Example 2: School Dispute
 *    - Parent: "My invoice was $500, now it's $1000!"
 *    - Audit log shows: Invoice updated by Admin X on date Y
 *    - Changes: {before: {amount: 500}, after: {amount: 1000}}
 *    - Resolves dispute with evidence
 * 
 *    Example 3: Security Breach
 *    - Unauthorized access to student records
 *    - Audit log shows: Failed login attempts from IP X
 *    - Can trace: What data was accessed, by whom, when
 *    - Critical for forensics and notification requirements
 * 
 * Q: What should be logged?
 * A: DECISION MATRIX:
 * 
 *    ALWAYS LOG:
 *    - Authentication events (login, logout, failures)
 *    - Data modifications (create, update, delete)
 *    - Financial transactions
 *    - Permission changes
 *    - Data exports
 *    - Security events
 * 
 *    CONSIDER LOGGING:
 *    - Read operations on sensitive data
 *    - Search queries
 *    - Report generation
 * 
 *    NEVER LOG:
 *    - Passwords (ever!)
 *    - Sensitive financial details (card numbers)
 *    - Full personal data (log references only)
 * 
 * Q: Why store 'changes' (before/after)?
 * A: FORENSICS AND ROLLBACK
 * 
 *    Without changes:
 *    - "User X updated student Y" (not helpful)
 *    
 *    With changes:
 *    - "User X changed student Y's grade from 'B' to 'A'"
 *    - Can rollback if needed
 *    - Can analyze what changed over time
 * 
 * Q: Performance impact?
 * A: MANAGED CAREFULLY:
 * 
 *    Async logging pattern:
 *    ```javascript
 *    // Don't wait for audit log
 *    AuditLog.log({ ... }).catch(console.error);
 *    res.json({ success: true });
 *    ```
 * 
 *    Indexes:
 *    - Crucial for querying historical logs
 *    - Time-based indexes for range queries
 * 
 *    Archival strategy:
 *    - Keep 1-2 years in hot storage
 *    - Archive older logs to cold storage
 *    - Never delete (compliance)
 * 
 * Q: Why prevent updates/deletes?
 * A: INTEGRITY
 *    - Audit logs must be tamper-proof
 *    - If you can edit logs, they're meaningless
 *    - Middleware prevents accidental modification
 *    - In production, might use write-once storage
 * 
 * Q: What about log growth?
 * A: SCALING STRATEGY:
 * 
 *    Short-term (< 100K records):
 *    - Single collection with indexes works fine
 * 
 *    Medium-term (100K - 10M records):
 *    - Monthly collections: auditlogs_2025_01
 *    - Query only relevant months
 * 
 *    Long-term (> 10M records):
 *    - Time-series collections
 *    - Archival to data warehouse
 *    - MongoDB Atlas Online Archive
 * 
 * PRODUCTION TIP:
 * Never let audit logging fail the main operation.
 * Wrap in try-catch, log errors, but continue.
 */

module.exports = mongoose.model('AuditLog', auditLogSchema);